#ifndef MyFont_h
#define MyFont_h

enum class extraFont6x6 {
  ARROW_UP = 0x80,
  ARROW_DOWN,
  ARROW_LEFF,
  ARROW_RIGHT,
  HINT_UP,
  HINT_DOWN,
  HINT_LEFT,
  HINT_RIGHT,
  LITTLE_OKAY,
  UNCHECKED,
  CHECKED
};

const uint8_t font6x6Set [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x37, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x00, 0x03,
  0x07, 0x00, 0x12, 0x3f, 0x3f, 0x12, 0x3f, 0x12, 0x24, 0x2a, 0x3f, 0x2a, 0x3a, 0x12, 0x23, 0x33,
  0x18, 0x06, 0x33, 0x31, 0x1a, 0x3f, 0x25, 0x3f, 0x3a, 0x28, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00,
  0x1e, 0x3f, 0x21, 0x00, 0x00, 0x00, 0x21, 0x3f, 0x1e, 0x00, 0x00, 0x00, 0x14, 0x08, 0x14, 0x00,
  0x00, 0x00, 0x08, 0x08, 0x3e, 0x3e, 0x08, 0x08, 0x38, 0x18, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08,
  0x08, 0x08, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x30, 0x3c, 0x0f, 0x03, 0x00, 0x00,
  0x1e, 0x3f, 0x29, 0x25, 0x3f, 0x1e, 0x22, 0x3f, 0x3f, 0x20, 0x00, 0x00, 0x22, 0x33, 0x39, 0x29,
  0x2f, 0x26, 0x11, 0x31, 0x25, 0x25, 0x3f, 0x1a, 0x0f, 0x0f, 0x08, 0x3e, 0x3e, 0x08, 0x17, 0x37,
  0x25, 0x25, 0x3d, 0x19, 0x1e, 0x3f, 0x25, 0x25, 0x3d, 0x18, 0x01, 0x01, 0x39, 0x3d, 0x07, 0x03,
  0x1a, 0x3f, 0x25, 0x25, 0x3f, 0x1a, 0x06, 0x2f, 0x29, 0x29, 0x3f, 0x1e, 0x36, 0x36, 0x00, 0x00,
  0x00, 0x00, 0x3b, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1c, 0x36, 0x22, 0x00, 0x00, 0x14, 0x14,
  0x14, 0x14, 0x00, 0x00, 0x22, 0x36, 0x1c, 0x08, 0x00, 0x00, 0x02, 0x03, 0x29, 0x2d, 0x07, 0x03,
  0x1e, 0x21, 0x2d, 0x2b, 0x2f, 0x16, 0x3e, 0x3f, 0x09, 0x09, 0x3f, 0x3e, 0x3f, 0x3f, 0x25, 0x25,
  0x3f, 0x1a, 0x1e, 0x3f, 0x21, 0x21, 0x33, 0x12, 0x3f, 0x3f, 0x21, 0x21, 0x1f, 0x1e, 0x3f, 0x3f,
  0x29, 0x29, 0x21, 0x21, 0x3f, 0x3f, 0x09, 0x09, 0x01, 0x01, 0x1e, 0x3f, 0x21, 0x29, 0x19, 0x38,
  0x3f, 0x3f, 0x08, 0x08, 0x3f, 0x3f, 0x21, 0x3f, 0x3f, 0x21, 0x00, 0x00, 0x10, 0x21, 0x21, 0x3f,
  0x1f, 0x01, 0x3f, 0x3f, 0x0c, 0x1e, 0x3b, 0x31, 0x3f, 0x3f, 0x20, 0x20, 0x20, 0x20, 0x3f, 0x27,
  0x0e, 0x07, 0x3f, 0x3f, 0x3f, 0x3f, 0x06, 0x0c, 0x3f, 0x3f, 0x1e, 0x3f, 0x21, 0x21, 0x3f, 0x1e,
  0x3f, 0x3f, 0x09, 0x09, 0x0f, 0x06, 0x1e, 0x3f, 0x21, 0x11, 0x3f, 0x2e, 0x3f, 0x3f, 0x09, 0x19,
  0x3f, 0x26, 0x26, 0x27, 0x25, 0x25, 0x3d, 0x1d, 0x01, 0x01, 0x3f, 0x3f, 0x01, 0x01, 0x1f, 0x3f,
  0x20, 0x20, 0x3f, 0x1f, 0x0f, 0x1f, 0x30, 0x30, 0x1f, 0x0f, 0x3f, 0x31, 0x18, 0x30, 0x3f, 0x3f,
  0x21, 0x33, 0x1e, 0x1e, 0x33, 0x21, 0x07, 0x0f, 0x08, 0x38, 0x3f, 0x07, 0x21, 0x31, 0x39, 0x2d,
  0x27, 0x23, 0x3f, 0x3f, 0x21, 0x00, 0x00, 0x00, 0x03, 0x0f, 0x3c, 0x30, 0x00, 0x00, 0x21, 0x3f,
  0x3f, 0x00, 0x00, 0x00, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x12, 0x3a, 0x2a, 0x2e, 0x3e, 0x1c, 0x3f, 0x3f, 0x22, 0x22,
  0x1e, 0x1c, 0x1c, 0x3e, 0x22, 0x22, 0x36, 0x14, 0x1c, 0x3c, 0x22, 0x22, 0x3f, 0x3f, 0x1c, 0x3e,
  0x2a, 0x2a, 0x2e, 0x0c, 0x04, 0x3e, 0x3f, 0x05, 0x05, 0x00, 0x06, 0x0f, 0x29, 0x29, 0x2f, 0x1e,
  0x3f, 0x3f, 0x02, 0x02, 0x3e, 0x3c, 0x3d, 0x3d, 0x20, 0x00, 0x00, 0x00, 0x10, 0x20, 0x20, 0x3d,
  0x1d, 0x00, 0x3f, 0x3f, 0x18, 0x1c, 0x36, 0x22, 0x1f, 0x3f, 0x20, 0x10, 0x00, 0x00, 0x3e, 0x06,
  0x3c, 0x06, 0x3e, 0x3e, 0x3e, 0x3c, 0x04, 0x06, 0x3e, 0x3c, 0x1c, 0x3e, 0x22, 0x22, 0x3e, 0x1c,
  0x3e, 0x3e, 0x12, 0x12, 0x1e, 0x0c, 0x06, 0x0f, 0x09, 0x09, 0x3f, 0x3e, 0x3e, 0x3e, 0x04, 0x06,
  0x02, 0x00, 0x2c, 0x2e, 0x2a, 0x2a, 0x3a, 0x1a, 0x02, 0x3f, 0x3f, 0x22, 0x00, 0x00, 0x1e, 0x3e,
  0x20, 0x20, 0x3e, 0x1e, 0x0e, 0x1e, 0x30, 0x30, 0x1e, 0x0e, 0x3e, 0x30, 0x1e, 0x30, 0x3e, 0x3e,
  0x22, 0x36, 0x1c, 0x1c, 0x36, 0x22, 0x07, 0x0f, 0x28, 0x38, 0x1f, 0x0f, 0x22, 0x32, 0x32, 0x2a,
  0x2e, 0x26, 0x08, 0x1e, 0x3f, 0x21, 0x00, 0x00, 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x21, 0x3f,
  0x1e, 0x08, 0x00, 0x00, 0x18, 0x0c, 0x0c, 0x18, 0x18, 0x0c, 0x08, 0x1c, 0x3e, 0x08, 0x08, 0x0e,
  0x04, 0x06, 0x3f, 0x3f, 0x06, 0x04, 0x08, 0x18, 0x3f, 0x3f, 0x18, 0x08, 0x0c, 0x1e, 0x3f, 0x0c,
  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3f, 0x1e, 0x0c, 0x1c, 0x0e, 0x07, 0x07, 0x0e, 0x1c, 0x0e, 0x1c,
  0x38, 0x38, 0x1c, 0x0e, 0x0c, 0x1e, 0x3f, 0x33, 0x21, 0x00, 0x00, 0x21, 0x33, 0x3f, 0x1e, 0x0c,
  0x0c, 0x12, 0x0c, 0x1e, 0x04, 0x1a, 0x1e, 0x21, 0x21, 0x21, 0x21, 0x1e, 0x16, 0x2d, 0x39, 0x2e,
  0x27, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

class Font6x6 {
  public:
    // variables to store the current cursor position
    int16_t x;
    int16_t y;

    // variable to store the color
    uint8_t color;

    // constants
    static const uint8_t maxCharWidth = 6;
    static const uint8_t spaceBetween = 1;

    void setColor(uint8_t n_c) {
      color = n_c;
    }

    void setCursor(int16_t n_x, int16_t n_y) {
      //Serial.println("set Cursor to: " + String(n_x) + " " + String(n_y));
      x = n_x;
      y = n_y;
    }

    uint8_t getOffset(uint8_t c) {
      //Serial.println("get Offset off " + String(char(c)));
      //TODO: i think there is something wrong with underscore and new_line uint8_ts
      if (c >= 0x20 && c < 0x90) {
        return c - 0x20;
      } else {
        return '?';
      }
    }


    uint8_t getLength(const __FlashStringHelper * ifsh) {

      // PGM_P is just a const uint8_t*
      // reinterpret_cast< > to cast from __FlashStringHelper type
      // this line is from Print.h, it gets me something I can work with
      PGM_P p = reinterpret_cast<PGM_P>(ifsh);
      uint8_t len = 0;
      while (1) {
        uint8_t c = pgm_read_byte(p++);

        len += getCharLength(c);
        if (c == 0)
          break;

        len += spaceBetween;
      }
      return len - spaceBetween;
    }

    uint8_t getLength(uint16_t c, uint8_t format) {
      if (format == DEC) {
        uint8_t len = 0;
        while (1) {
          len += getCharLength((c % 10) + '0');
          c /= 10;
          if (c == 0)
            break;
          len += spaceBetween;
        }
        return len;
      }
    }

    uint8_t getCharLength(uint8_t c) {
      if (c == ' ' || c == 0)
        return maxCharWidth;

      uint8_t Offset = getOffset(c);
      //Serial.println("getOffset:" + String(uint8_tOffset) + " of uint8_t:" + String(c));
      for (uint8_t len = maxCharWidth; len > 0; len--) {
        if (pgm_read_byte(font6x6Set + Offset * maxCharWidth + len - 1) != 0x00) {
          //Serial.println("for char " + String(char(c)) + " len is:" + String(len));
          return len;
        }
      }
      return 0;
    }

    bool isExtraLow(uint8_t c) {
      if (c == 'g' || c == 'q' || c == 'y') {
        return true;
      } else {
        return false;
      }
    }

    void print(extraFont6x6 c) {
      print(uint8_t(c));
    }

    void print(uint8_t c) {

      if (x < -maxCharWidth || x > WIDTH)
        return;

      if (y < -(maxCharWidth + 1) || y > HEIGHT)
        return;

      if (isExtraLow(c))
        y += 1;

      uint8_t len = getCharLength(c);

      drawChar(x, y, font6x6Set, len, getOffset(c), color);

      if (isExtraLow(c))
        y -= 1;

      x += (len + spaceBetween);
    }

    /*
      void print(String s) {
      for (uint8_t i = 0; i < s.length(); i++) {
        print(s.uint8_tAt(i));
      }
      }
    */

    void print(int32_t v, uint8_t format) {
      if (format == DEC) {
        // maybe take care of minus values
        if (v < 0) {
          // TODO: remember minus
          v *= (-1);
        }

        int32_t dividor = 1;
        uint8_t stellen = 0;

        int32_t tmp = v;
        while (tmp > 0) {
          stellen++;
          tmp /= 10;
          if (tmp > 0)
            dividor *= 10;
        }

        for (uint8_t i = 0; i < stellen; i++) {
          uint16_t currentValue = v / dividor;
          uint8_t currentNumber = currentValue % 10;
          print(currentNumber + '0');
          dividor /= 10;
        }
      }
    }

    uint8_t getLength(const uint8_t *p, uint8_t offset, uint8_t len) {
      uint8_t l = 0;
      for (uint8_t i = 0; i < len; i++) {
        uint8_t c = pgm_read_byte(p + i + offset * len);
        l += getCharLength(c);
        if (c == '\0')
          return l;
        l += spaceBetween;
      }
      return l;
    }

    void print(const uint8_t *p, uint8_t offset, uint8_t len) {
      for (uint8_t i = 0; i < len; i++) {
        uint8_t c = pgm_read_byte(p + i + offset * len);
        if (c == '\0')
          return;
        print(c);
      }
    }

    void print(const __FlashStringHelper * ifsh) {

      // PGM_P is just a const uint8_t*
      // reinterpret_cast< > to cast from __FlashStringHelper type
      // this line is from Print.h, it gets me something I can work with
      PGM_P p = reinterpret_cast<PGM_P>(ifsh);

      while (1) {
        uint8_t c = pgm_read_byte(p++);

        print(c);
        if (c == 0)
          break;
      }
    }

    void drawChar(int16_t x, int16_t y, const uint8_t *data, uint8_t w, uint8_t offset, uint8_t color) {

      // no need to draw if out of screen
      if ((y + 8 < 0 || y > HEIGHT) || (x + w  < 0 || x > WIDTH))
        return;

      // this is a fast modulo 8
      int16_t yBitOffset = y & 7;

      // the horizontal bytes line where to draw
      int16_t yPos = (y / 8) * WIDTH;

      // multiply with width before the for loop, it is only to get easier offsets values
      uint16_t offsetWidth = offset * maxCharWidth;

      for (uint16_t i = 0; i < w; i++) {

        // get the byte to draw
        byte currentByte = pgm_read_byte(data + offsetWidth + i);

        int16_t xPos = x + i;
        int16_t bytePos = xPos + yPos;

        if (bytePos >=  0  && bytePos < (WIDTH * HEIGHT / 8) &&
            xPos    >=  0  && xPos    < WIDTH ) {

          if (y >= 0) {
            // shift pixels left/down and draw the top of the byte
            if (color == BLACK) {
              arduboy.sBuffer[bytePos] &= ~(currentByte << yBitOffset);
            } else {
              arduboy.sBuffer[bytePos] |= (currentByte << yBitOffset);
            }

            // shift the pixels right/up and draw cut bitmap
            if (yBitOffset != 0 && bytePos < ((WIDTH * HEIGHT / 8) - WIDTH)) {
              if (color == BLACK) {
                arduboy.sBuffer[bytePos + WIDTH] &= ~(currentByte >> (8 - yBitOffset));
              } else {
                arduboy.sBuffer[bytePos + WIDTH] |= (currentByte >> (8 - yBitOffset));
              }
            }

          }  else {
            // shift the pixels right/up and draw cut bitmap at the top of the screen
            if (color == BLACK) {
              arduboy.sBuffer[bytePos] &= ~(currentByte >> (8 - yBitOffset));
            } else {
              arduboy.sBuffer[bytePos] |= (currentByte >> (8 - yBitOffset));
            }

          }
        }
      }
    }
};

#endif
